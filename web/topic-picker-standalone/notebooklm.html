<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MSS Studio</title>
  <link rel="stylesheet" href="studio.css">
  <script src="version.js" defer></script>
</head>
<body>
  <div id="loadingBar" class="loading-bar"></div>
  <div class="card" style="display:flex; justify-content:space-between; align-items:center; gap:16px; flex-wrap:wrap;">
    <h1 style="margin:0;">MSS Studio <span id="appVersion" style="font-size:14px; color:#64748b; font-weight:400;">v-</span></h1>
    <div style="display:flex; gap:10px; flex-wrap:wrap; position:relative;">
      <button class="btn" onclick="window.location.href='index.html'">Topics</button>
      <button class="btn" onclick="window.location.href='avatar-manager.html'">Avatars</button>
      <button class="btn" onclick="window.location.href='logo-manager.html'">Logos</button>
      <button class="btn" onclick="window.location.href='thumbnail-manager.html'">Thumbnails</button>
      <button class="btn" onclick="window.location.href='intro-outro.html'">Intro/Outro</button>
      <button class="btn" onclick="window.location.href='viewer.html'">Viewer</button>
      <div class="dropdown" style="position:relative;">
        <button class="btn" id="oldMenusBtn">Old Menus</button>
        <div class="dropdown-content" id="oldMenus" style="display:none; position:absolute; top:110%; left:0; background:#0B0F19; border:1px solid #334; border-radius:8px; min-width:180px; z-index:20; box-shadow:0 6px 18px rgba(0,0,0,0.4);">
          <a href="video-composer.html" style="display:block; padding:8px 12px; color:#E8EBFF; text-decoration:none;">Composer</a>
          <a href="post-process.html" style="display:block; padding:8px 12px; color:#E8EBFF; text-decoration:none;">Post-Process</a>
          <a href="preview.html" style="display:block; padding:8px 12px; color:#E8EBFF; text-decoration:none;">Preview</a>
        </div>
      </div>
    </div>
  </div>

<script>(function(){ const btn=document.getElementById("oldMenusBtn"); const menu=document.getElementById("oldMenus"); if(btn&&menu){ btn.addEventListener("click",(e)=>{ e.stopPropagation(); menu.style.display=(menu.style.display==="block"?"none":"block");}); document.addEventListener("click",()=>{ menu.style.display="none";}); menu.addEventListener("click",(e)=>e.stopPropagation()); }})();</script>

  <div class="card">
    <h1>Topic Picker</h1>
    <div class="row" style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
      <button class="btn" id="liteLoadLast">Load Last Topic</button>
      <a class="btn" href="index.html?return=notebooklm.html" id="openFullPicker">Open Full Topic Picker</a>
      <span id="liteStatus" class="status info" style="display:none;"></span>
    </div>
    <div class="row" style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
      <div>
        <label>Title</label>
        <input id="liteTitle" placeholder="video Title" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;" />
      </div>
      <div>
        <label>Angle / Hook</label>
        <input id="liteHook" placeholder="Hook / Angle" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;" />
      </div>
      <div style="grid-column: 1 / span 2;">
        <label>Keywords (comma or space separated)</label>
        <input id="liteKeywords" placeholder="ai, 2025, automation, future of work" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;" />
      </div>
    </div>
  </div>
  <script>
    (function(){
      function renderTokens(keywords){
        try {
          const cont = document.getElementById('topicTokens');
          if (!cont) return;
          cont.innerHTML = '';
          (keywords||[]).forEach(kw => {
            const b = document.createElement('span');
            b.textContent = kw;
            b.style.padding='4px 8px'; b.style.border='1px solid #334'; b.style.borderRadius='6px'; b.style.cursor='pointer'; b.style.fontSize='12px';
            b.onclick = () => {
              const target = (document.querySelector('input[name="memeTarget"]:checked')||{}).value || 'bottom';
              const el = document.getElementById(target==='top' ? 'memeTop' : 'memeBottom');
              if (el) { el.value = (el.value ? el.value + ' ' : '') + kw; el.focus(); }
            };
            cont.appendChild(b);
          });
        } catch {}
      }

      function tryLoad(){
        try {
          const raw = localStorage.getItem('editingTopic');
          if (!raw) return false;
          const t = JSON.parse(raw);
          if (!t) return false;

          // Check if all required fields exist in DOM
          const topicTitle = document.getElementById('topicTitle');
          const topicHook = document.getElementById('topicHook');
          const topicDesc = document.getElementById('topicDesc');
          const memeTop = document.getElementById('memeTop');
          const memeBottom = document.getElementById('memeBottom');

          if (!topicTitle || !topicHook || !topicDesc || !memeTop || !memeBottom) {
            return false;
          }

          const title = t.yt_title || t.title || '';
          const hook = t.angle || '';
          const desc = t.yt_description || '';
          const keywords = t.keywords || [];

          // Inline Picker fields
          const liteTitle = document.getElementById('liteTitle');
          const liteHook = document.getElementById('liteHook');
          const liteKw = document.getElementById('liteKeywords');
          if (liteTitle) liteTitle.value = title;
          if (liteHook) liteHook.value = hook;
          if (liteKw) liteKw.value = keywords.join(', ');

          // Meme Creator (Quick) fields
          topicTitle.value = title;
          topicHook.value = hook;
          topicDesc.value = desc;

          // Meme Creator text fields
          if (title) memeTop.value = title.toUpperCase();
          if (hook) memeBottom.value = hook;

          renderTokens(keywords);

          const s = document.getElementById('liteStatus');
          if (s) { s.textContent = 'Loaded topic from picker'; s.className='status ok'; s.style.display='block'; }

          return true;
        } catch(e) {
          console.error('Error loading topic:', e);
          return false;
        }
      }

      // Aggressive retry strategy - keep trying until it works or we give up
      let attempts = 0;
      const maxAttempts = 20;

      function retryLoad() {
        attempts++;
        if (tryLoad()) {
          return;
        }
        if (attempts < maxAttempts) {
          setTimeout(retryLoad, 200);
        }
      }

      // Start trying immediately
      retryLoad();

      // Also try when page is fully loaded
      window.addEventListener('load', tryLoad);

      // And when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', tryLoad);
      }

      const btn = document.getElementById('liteLoadLast');
      if (btn) btn.addEventListener('click', tryLoad);
    })();
  </script>

  <div class="card">
    <h1>Video w/Audio Loader</h1>
    <div class="row">
      <label for="mainFile">NotebookLM video (required):</label>
      <input type="file" id="mainFile" accept="video/*">
    </div>
    <div class="controls">
      <label style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="toggleAvatar" checked>
        Include avatar (lower-right)
      </label>
      <div id="avatarSelectWrap" style="display:flex; align-items:center; gap:6px;">
        <span style="font-size:13px; color:#94a3b8;">Avatar:</span>
        <select id="avatarSelect" style="padding:6px 10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;"></select>
        <img id="activeAvatarImg" alt="Active Avatar" style="width:48px; height:48px; border-radius:8px; object-fit:cover; border:1px solid #334; background:#0B0F19; display:none; vertical-align:middle;"/>
      </div>
      <label style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="avatarAnimated" checked>
        Animated avatar (D-ID/FFmpeg)
      </label>
      <label style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="skipDID" checked>
        Skip D-ID (use local animation)
      </label>
      <label style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="toggleLogo" checked>
        Include logo
      </label>
      <div id="logoSelectWrap" style="display:flex; align-items:center; gap:6px;">
        <span style="font-size:13px; color:#94a3b8;">Logo:</span>
        <select id="logoSelect" style="padding:6px 10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;"></select>
        <img id="activeLogoImg" alt="Active Logo" style="width:48px; height:48px; border-radius:8px; object-fit:contain; border:1px solid #334; background:#0B0F19; display:none; vertical-align:middle;"/>
      </div>
      <div id="logoPositionWrap" style="display:flex; align-items:center; gap:6px;">
        <span style="font-size:13px; color:#94a3b8;">Position:</span>
        <select id="logoPos" style="padding:6px 10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;">
          <option value="bottom-left">Bottom-Left</option>
          <option value="bottom-right">Bottom-Right</option>
          <option value="top-left">Top-Left</option>
          <option value="top-right">Top-Right</option>
          <option value="center">Center</option>
        </select>
      </div>
      <label style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="toggleIntroOutro">
        Include intro/outro
      </label>
    </div>
    <div class="row">
      <button class="btn" id="approveBtn" disabled>Approve & Process</button>
    </div>
    <div id="status" class="status"></div>
    <div class="row">
      <video id="preview" controls style="display:none;"></video>
    </div>
  </div>

  <div class="card" style="margin-top:16px;">
    <h1>AI Meme Prompt</h1>
    <div class="row">
      <label>Prompt (persists locally; only changes if you edit it)</label>
      <textarea id="memePrompt" class="large" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF; height:140px;"></textarea>
    </div>
    <div class="row" style="color:#94a3b8; font-size:12px;">Tip: {{title}} will be replaced with the Title abov-e.</div>
  </div>

  <div class="card" style="margin-top:16px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; flex-wrap:wrap; gap:8px;">
      <h1 style="margin:0;">Meme Creator (Quick)</h1>
      <div style="display:flex; gap:8px;">
        <button class="btn" id="saveTemplateBtn" style="font-size:12px; padding:6px 12px; background:#7c3aed; border-color:#7c3aed;">üíæ Save Template</button>
        <button class="btn" id="loadTemplateBtn" style="font-size:12px; padding:6px 12px; background:#7c3aed; border-color:#7c3aed;">üìÅ Templates</button>
        <button class="btn" id="showRecentBtn" style="font-size:12px; padding:6px 12px;">Recent ‚ñæ</button>
        <button class="btn" id="exportBtn" style="font-size:12px; padding:6px 12px; background:#0891b2; border-color:#0891b2;">‚¨á Export</button>
        <button class="btn" id="importBtn" style="font-size:12px; padding:6px 12px; background:#0891b2; border-color:#0891b2;">‚¨Ü Import</button>
      </div>
    </div>
    <input type="file" id="importFileInput" accept=".json" style="display:none;">
    <div id="templatePanel" style="display:none; background:rgba(124,58,237,0.1); border:1px solid #7c3aed; border-radius:6px; padding:12px; margin-bottom:12px; max-height:250px; overflow-y:auto;">
      <div style="font-size:13px; color:var(--text-muted); margin-bottom:8px;">Saved Templates (click to load):</div>
      <div id="templateList"></div>
    </div>
    <div id="recentTopics" style="display:none; background:rgba(59,130,246,0.1); border:1px solid var(--accent-blue); border-radius:6px; padding:12px; margin-bottom:12px; max-height:200px; overflow-y:auto;">
      <div style="font-size:13px; color:var(--text-muted); margin-bottom:8px;">Recent topics (click to load):</div>
      <div id="recentList"></div>
    </div>
    <div class="row">
      <label>Title</label>
      <input id="topicTitle" placeholder="video Title" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;" />
    </div>
    <div class="row">
      <label>Angle / Hook</label>
      <input id="topicHook" placeholder="Hook / Angle" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;" />
    </div>
    <div class="row">
      <label>YouTube Description</label>
      <textarea id="topicDesc" class="large" placeholder="YouTube description" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;"></textarea>
    </div>
    <div class="row">
      <label>Top Text</label>
      <input id="memeTop" placeholder="MANY SOURCES SAY" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;" />
    </div>
    <div class="row">
      <label>Bottom Text</label>
      <input id="memeBottom" placeholder="Because one source is N-ever enough" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;" />
    </div>
    <div class="row">
      <label>Font Style</label>
      <select id="memeFont" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;">
        <option value="Impact">Impact (Classic Meme)</option>
        <option value="Arial Black">Arial Black (Bold)</option>
        <option value="Bebas Neue">Bebas Neue (Modern)</option>
        <option value="Anton">Anton (Heavy)</option>
        <option value="Oswald">Oswald (Clean)</option>
        <option value="Archivo Black">Archivo Black (Strong)</option>
      </select>
    </div>
    <div class="controls">
      <label>Background Image: <input type="file" id="memeBg" accept="image/*"></label>
      <div style="color:var(--text-muted); font-size:12px;">Or drag & drop image onto canvas</div>
      <button class="btn" id="memeGenBg">Generate Background (AI)</button>
      <button class="btn" id="batchGenBg" style="background:#059669; border-color:#059669;">Generate 5 Variants</button>
      <label style="display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="forceCleanBg" checked> Force clean (no text)
      </label>
      <button class="btn" id="memeGenerate">Render Meme</button>
      <a class="btn" id="memeDownload" download="meme.png" style="display:none;">Download</a>
    </div>
    <div class="row">
      <canvas id="memecanvas" width="1280" height="720" style="width:100%; max-width:720px; border-radius:8px; background:#000;"></canvas>
    </div>
  </div>

  <div class="card" style="margin-top:16px;">
    <h1>üé¨ AI Script Generator</h1>
    <div class="row" style="background:rgba(59,130,246,0.1); border:1px solid var(--accent-blue); border-radius:6px; padding:12px;">
      <div style="font-size:13px; color:var(--text-muted); margin-bottom:8px;">
        Generate a complete video script based on your topic. Uses your title, hook, and keywords.
      </div>
    </div>
    <div class="row">
      <label>Script Length</label>
      <select id="scriptLength" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;">
        <option value="short">Short (30-60 seconds)</option>
        <option value="medium" selected>Medium (2-3 minutes)</option>
        <option value="long">Long (5-8 minutes)</option>
      </select>
    </div>
    <div class="row">
      <label>Script Style</label>
      <select id="scriptStyle" style="width:100%; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF;">
        <option value="informative" selected>Informative (Educational)</option>
        <option value="entertaining">Entertaining (Engaging)</option>
        <option value="dramatic">Dramatic (Storytelling)</option>
        <option value="casual">Casual (Conversational)</option>
        <option value="professional">Professional (News-style)</option>
      </select>
    </div>
    <div class="controls">
      <button class="btn" id="generateScript" style="background:#8b5cf6; border-color:#8b5cf6;">‚ú® Generate Script</button>
      <button class="btn" id="copyScript" style="display:none;">üìã Copy Script</button>
    </div>
    <div id="scriptStatus" class="status" style="display:none;"></div>
    <div class="row" id="scriptOutputRow" style="display:none;">
      <label>Generated Script</label>
      <textarea id="scriptOutput" style="width:100%; min-height:300px; padding:10px; border-radius:6px; border:1px solid #334; background:#0B0F19; color:#E8EBFF; font-family:monospace; line-height:1.6;"></textarea>
      <div style="margin-top:8px; display:flex; gap:12px; color:var(--text-muted); font-size:12px;">
        <span id="scriptWordCount">Words: 0</span>
        <span id="scriptDuration">Est. Duration: 0s</span>
      </div>
    </div>
  </div>

  <script>
    const API_BASE = 'http://127.0.0.1:5000';
    const DEFAULT_PROMPT = `Create a vibrant, eye-catching YouTube thumbnail for a video titled: {{title}}

Style: Bold, high-contrast, professional
Elements: Large readable text, dramatic v-isuals, bright colors
Emotion: Exciting, curiosity-inducing, click-worthy
Format: 1280x720 pixels, 16:9 aspect ratio

Make it stand out in search results and suggested videos.`;

    function liteStatus(msg, kind='info') {
      const el = document.getElementById('liteStatus');
      el.style.display = 'inline-block';
      el.className = 'status ' + (kind || 'info');
      el.textContent = msg;
    }

    function parseKeywords(str) {
      if (!str) return [];
      const raw = str.split(/[\s,]+/).map(s => s.trim()).filter(Boolean);
      // de-dup while preserv-ing order
      const seen = new Set(); const out = [];
      for (const w of raw) { if (!seen.has(w.toLowerCase())) { seen.add(w.toLowerCase()); out.push(w); } }
      return out.slice(0, 50);
    }

    // Load & persist prompt
    (function initMemePrompt(){
      const ta = document.getElementById('memePrompt');
      const saved = localStorage.getItem('memePrompt');
      ta.value = saved && saved.trim() ? saved : DEFAULT_PROMPT;
      ta.addEventListener('input', () => {
        localStorage.setItem('memePrompt', ta.value);
      });
    })();

    // Fetch and display Version from API
    (function loadVersion(){
      fetch(`${API_BASE}/health`).then(r => r.json()).then(j => {
        const el = document.getElementById('appVersion');
        if (el && j && j.Version) el.textContent = 'v-' + j.Version;
      }).catch(()=>{
        const el = document.getElementById('appVersion');
        if (el) el.textContent = 'v-2.3.1';
      });
    })();

    // Persistence of logo position and toggles
    (function initHeader(){
      const posEl = document.getElementById('logoPos');
      // restore saved position
      const savedPos = localStorage.getItem('logo_position');
      if (savedPos) posEl.value = savedPos;
      posEl.addEventListener('change', ()=> localStorage.setItem('logo_position', posEl.value));
      // Persist toggles
      const persist = (id)=>{ const el = document.getElementById(id); const k = 'persist_'+id; const sv = localStorage.getItem(k); if(sv!==null) el.checked = (sv==='true'); el.addEventListener('change', ()=> localStorage.setItem(k, el.checked)); };
      persist('toggleAvatar');
      persist('avatarAnimated');
      persist('skipDID');
      persist('toggleLogo');
      persist('toggleIntroOutro');
    })();

    // Persist Force Clean preference (default true)
    (function initForceClean(){
      const cb = document.getElementById('forceCleanBg');
      const saved = localStorage.getItem('forceCleanBg');
      if (saved !== null) cb.checked = (saved === 'true');
      cb.addEventListener('change', () => localStorage.setItem('forceCleanBg', cb.checked));
    })();

    function applyTopicToUI(topic) {
      try {
        localStorage.setItem('editingTopic', JSON.stringify(topic));
      } catch {}
      // Populate Meme Creator fields
      const title = topic.title || topic.yt_title || '';
      const hook = topic.angle || topic.hook || '';
      const desc = topic.yt_description || topic.description || '';
      const kw = topic.keywords || topic.yt_tags || [];
      const uniq = Array.from(new Set([...(kw||[])]));
        const tTitle = document.getElementById('topicTitle'); if (tTitle) tTitle.value = title;
        const tHook = document.getElementById('topicHook'); if (tHook) tHook.value = hook;
        const tDesc = document.getElementById('topicDesc'); if (tDesc) tDesc.value = desc;
        // Populate Inline Picker fields
        const lTitle = document.getElementById('liteTitle'); if (lTitle) lTitle.value = title;
        const lHook = document.getElementById('liteHook'); if (lHook) lHook.value = hook;
        const lKw = document.getElementById('liteKeywords'); if (lKw) lKw.value = uniq.join(', ');
        // Populate Meme Creator text fields
        const mTop = document.getElementById('memeTop'); if (mTop && title) mTop.value = title.toUpperCase();
        const mBottom = document.getElementById('memeBottom'); if (mBottom && hook) mBottom.value = hook;
      // Render keyword chips
      const tokensEl = document.getElementById('topicTokens');
      if (tokensEl) {
        tokensEl.innerHTML = '';
          const target = () => (document.querySelector('input[name="memeTarget"]:checked')?.value || 'bottom');
        uniq.slice(0, 50).forEach(t => {
          const chip = document.createElement('span');
          chip.textContent = t;
          chip.style.cssText = 'background:#1e3a8a; border-radius:14px; padding:6px 10px; font-size:12px; cursor:pointer;';
          chip.onclick = () => {
            const which = target();
            const input = which === 'top' ? document.getElementById('memeTop') : document.getElementById('memeBottom');
            const sep = input.value && !input.value.endsWith(' ') ? ' ' : '';
            input.value = input.value + sep + t;
          };
          tokensEl.appendChild(chip);
        });
      }
      // Persist to backend (best-effort)
      fetch(`${API_BASE}/set-selected-topic`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(topic)
      }).catch(()=>{});
      liteStatus('Topic applied.', 'ok');
    }

    // Wire Inline Picker controls
    document.getElementById('liteLoadLast').addEventListener('click', async () => {
      liteStatus('Loading last topic...', 'info');
      try {
        const r = await fetch(`${API_BASE}/get-selected-topic`);
        const j = await r.json();
        if (!j.success) throw new Error(j.error || 'Not found');
        applyTopicToUI(j.topic || {});
      } catch (e) {
        liteStatus('Error: ' + e.message, 'err');
      }
    });

    // Render meme text overlay (Top/Bottom) on the current canvas and enable download
    function drawGradientBG(ctx, w, h) {
      const g = ctx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0, '#101827');
      g.addColorStop(1, '#0b0f19');
      ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
      ctx.globalAlpha = 0.08; ctx.strokeStyle = '#ffffff';
      for (let x = 0; x < w; x += 10) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x - 220, h); ctx.stroke(); }
      ctx.globalAlpha = 1;
    }

    function drawWrapped(ctx, text, opts) {
      const { x, y, maxWidth, align = 'center', base = 'top', maxLines = 3, fontSize = 96, color = '#fff', stroke = '#000', strokeW = 6, lineGap = 0.9, fontFamily } = opts || {};
      let size = fontSize;
      const selectedFont = fontFamily || document.getElementById('memeFont')?.value || 'Impact';
      ctx.textAlign = align; ctx.textBaseline = base; ctx.fillStyle = color; ctx.strokeStyle = stroke; ctx.lineJoin = 'round';

      function measureLines(sz) {
        ctx.font = `900 ${sz}px ${selectedFont}, sans-serif`;
        const words = (text || '').split(/\s+/).filter(Boolean);
        const lines = []; let cur = '';
        for (const w of words) {
          const test = cur ? cur + ' ' + w : w;
          if (ctx.measureText(test).width <= maxWidth || !cur) cur = test; else { lines.push(cur); cur = w; }
        }
        if (cur) lines.push(cur);
        return lines.slice(0, maxLines);
      }

      let lines = measureLines(size);
      while (lines.length > 0 && lines.some(l => ctx.measureText(l).width > maxWidth) && size > 28) {
        size -= 4; lines = measureLines(size);
      }
      ctx.font = `900 ${size}px ${selectedFont}, sans-serif`;
      const lh = size * lineGap;
      lines.forEach((line, i) => {
        const yy = y + i * lh;
        if (strokeW) { ctx.lineWidth = strokeW; ctx.strokeText(line, x, yy); }
        ctx.fillText(line, x, yy);
      });
    }

    document.getElementById('memeGenerate').addEventListener('click', () => {
      const canvas = document.getElementById('memecanvas');
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;

      // If canvas is blank, lay down a gradient first
      try {
        const p = ctx.getImageData(0, 0, 1, 1).data; // if all zeros, assume blank
        if ((p[0]|p[1]|p[2]|p[3]) === 0) drawGradientBG(ctx, w, h);
      } catch { drawGradientBG(ctx, w, h); }

      const topInput = document.getElementById('memeTop');
      const bottomInput = document.getElementById('memeBottom');
      const top = (topInput.value || topInput.getAttribute('placeholder') || 'MANY SOURCES SAY').trim();
      const bottom = (bottomInput.value || bottomInput.getAttribute('placeholder') || 'Because one source is NEv-ER enough').trim();

      // Safe zones and max widths
      const padX = Math.round(w * 0.06);
      const topY = Math.round(h * 0.10);
      const botY = Math.round(h * 0.78);
      const maxW = w - padX * 2;

      if (top) drawWrapped(ctx, top.toUpperCase(), { x: w/2, y: topY, maxWidth: maxW, align: 'center', base: 'top', fontSize: 96, strokeW: 12, color: '#FFD700' });
      if (bottom) drawWrapped(ctx, bottom, { x: w/2, y: botY, maxWidth: maxW, align: 'center', base: 'top', fontSize: 80, strokeW: 10 });

      const link = document.getElementById('memeDownload');
      try { link.href = canvas.toDataURL('image/png'); link.style.display = 'inline-block'; } catch {}
      setStatus('Meme rendered.', 'ok');
    });

    const mainInput = document.getElementById('mainFile');
    const approveBtn = document.getElementById('approveBtn');
    const statusBox = document.getElementById('status');
    const preview = document.getElementById('preview');
    const toggleAvatar = document.getElementById('toggleAvatar');
    const avatarSelect = document.getElementById('avatarSelect');
    const avatarSelectWrap = document.getElementById('avatarSelectWrap');
    const toggleLogo = document.getElementById('toggleLogo');
    const toggleIntroOutro = document.getElementById('toggleIntroOutro');

    function setStatus(text, kind) {
      statusBox.style.display = 'block';
      statusBox.className = 'status ' + (kind || 'info');
      statusBox.textContent = text;
    }

    function clearStatus() { statusBox.style.display = 'none'; }

    // Toast Notification System
    function showToast(message, type = 'info', duration = 4000) {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <span>${message}</span>
        <span class="toast-close">‚úï</span>
      `;

      document.body.appendChild(toast);

      const close = () => {
        toast.style.animation = 'slideIn 0.3s ease reverse';
        setTimeout(() => toast.remove(), 300);
      };

      toast.querySelector('.toast-close').addEventListener('click', close);

      if (duration > 0) {
        setTimeout(close, duration);
      }

      return toast;
    }

    // Enhanced error handling with retry
    async function fetchWithRetry(url, options = {}, retries = 2) {
      for (let i = 0; i <= retries; i++) {
        try {
          const res = await fetch(url, options);
          if (!res.ok) {
            const text = await res.text().catch(() => '');
            throw new Error(`HTTP ${res.status}: ${text.slice(0, 100) || res.statusText}`);
          }
          return res;
        } catch (e) {
          if (i === retries) throw e;
          await new Promise(r => setTimeout(r, 1000 * (i + 1)));
          showToast(`Retrying... (${i + 1}/${retries})`, 'info', 2000);
        }
      }
    }

    // Undo/Redo System
    const undoStack = [];
    const redoStack = [];
    let currentState = null;

    function captureState() {
      return {
        title: document.getElementById('topicTitle')?.value || '',
        hook: document.getElementById('topicHook')?.value || '',
        desc: document.getElementById('topicDesc')?.value || '',
        memeTop: document.getElementById('memeTop')?.value || '',
        memeBottom: document.getElementById('memeBottom')?.value || ''
      };
    }

    function saveStateToUndo() {
      const newState = captureState();
      if (JSON.stringify(newState) === JSON.stringify(currentState)) return;

      if (currentState) undoStack.push(currentState);
      currentState = newState;
      redoStack.length = 0; // Clear redo stack on new change

      if (undoStack.length > 50) undoStack.shift(); // Limit history
    }

    function undo() {
      if (undoStack.length === 0) {
        showToast('Nothing to undo', 'info', 2000);
        return;
      }

      redoStack.push(currentState);
      currentState = undoStack.pop();

      document.getElementById('topicTitle').value = currentState.title;
      document.getElementById('topicHook').value = currentState.hook;
      document.getElementById('topicDesc').value = currentState.desc;
      document.getElementById('memeTop').value = currentState.memeTop;
      document.getElementById('memeBottom').value = currentState.memeBottom;

      showToast('‚Ü∂ Undo', 'info', 1500);
      updateLivePreview();
    }

    function redo() {
      if (redoStack.length === 0) {
        showToast('Nothing to redo', 'info', 2000);
        return;
      }

      undoStack.push(currentState);
      currentState = redoStack.pop();

      document.getElementById('topicTitle').value = currentState.title;
      document.getElementById('topicHook').value = currentState.hook;
      document.getElementById('topicDesc').value = currentState.desc;
      document.getElementById('memeTop').value = currentState.memeTop;
      document.getElementById('memeBottom').value = currentState.memeBottom;

      showToast('‚Ü∑ Redo', 'info', 1500);
      updateLivePreview();
    }

    // Save state on input with debounce
    let undoTimer = null;
    ['topicTitle', 'topicHook', 'topicDesc', 'memeTop', 'memeBottom'].forEach(id => {
      document.getElementById(id)?.addEventListener('input', () => {
        clearTimeout(undoTimer);
        undoTimer = setTimeout(saveStateToUndo, 1000);
      });
    });

    // Initialize current state
    currentState = captureState();

    // Keyboard Shortcuts
    document.addEventListener('keydown', (e) => {
      // Ctrl+Z for Undo
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      }

      // Ctrl+Shift+Z or Ctrl+Y for Redo
      if (((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z') ||
          ((e.ctrlKey || e.metaKey) && e.key === 'y')) {
        e.preventDefault();
        redo();
      }

      // Ctrl+S or Cmd+S to generate video
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        const approveBtn = document.getElementById('approveBtn');
        if (approveBtn && !approveBtn.disabled) {
          approveBtn.click();
          showToast('Generating video...', 'info', 2000);
        }
      }

      // Ctrl+G to generate background
      if ((e.ctrlKey || e.metaKey) && e.key === 'g') {
        e.preventDefault();
        const genBgBtn = document.getElementById('memeGenBg');
        if (genBgBtn) {
          genBgBtn.click();
        }
      }

      // Escape to cancel/hide loading bar
      if (e.key === 'Escape') {
        const loadingBar = document.getElementById('loadingBar');
        if (loadingBar && loadingBar.style.display === 'block') {
          loadingBar.style.display = 'none';
          showToast('Operation cancelled', 'info', 2000);
        }
      }
    });

    toggleAvatar.addEventListener('change', () => {
      avatarSelectWrap.style.display = toggleAvatar.checked ? 'flex' : 'none';
    });

    // Load avatars
    async function loadavatars() {
      try {
        const res = await fetch(`${API_BASE}/get-avatar-library`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        avatarSelect.innerHTML = '';
        const list = (data && data.avatars) ? data.avatars : [];
        if (list.length === 0) {
          avatarSelect.innerHTML = '<option value="">No avatars found</option>';
          return;
        }

        const activeAvatarImg = document.getElementById('activeAvatarImg');
        let activeAvatar = null;

        list.forEach(a => {
          const opt = document.createElement('option');
          opt.value = a.id;
          opt.textContent = a.name || a.id;
          if (a.active) {
            opt.selected = true;
            activeAvatar = a;
          }
          avatarSelect.appendChild(opt);
        });

        // Display active avatar image
        if (activeAvatar && activeAvatarImg) {
          activeAvatarImg.src = activeAvatar.image_url;
          activeAvatarImg.style.display = 'inline-block';
          console.log('Active avatar loaded:', activeAvatar.name, activeAvatar.image_url);
        } else if (activeAvatarImg) {
          activeAvatarImg.style.display = 'none';
        }
      } catch (e) {
        console.error('Error loading avatars:', e);
        avatarSelect.innerHTML = '<option value="">Error loading avatars</option>';
        const activeAvatarImg = document.getElementById('activeAvatarImg');
        if (activeAvatarImg) activeAvatarImg.style.display = 'none';
      }
    }
    loadavatars();

    // Update avatar image when selection changes
    avatarSelect.addEventListener('change', async () => {
      const activeAvatarImg = document.getElementById('activeAvatarImg');
      if (!activeAvatarImg) return;

      const selectedId = avatarSelect.value;
      if (!selectedId) {
        activeAvatarImg.style.display = 'none';
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/get-avatar-library`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        const list = (data && data.avatars) ? data.avatars : [];
        const selectedAvatar = list.find(a => a.id === selectedId);

        if (selectedAvatar && selectedAvatar.image_url) {
          activeAvatarImg.src = selectedAvatar.image_url;
          activeAvatarImg.style.display = 'inline-block';
          console.log('Avatar changed to:', selectedAvatar.name, selectedAvatar.image_url);
        } else {
          activeAvatarImg.style.display = 'none';
        }
      } catch (e) {
        console.error('Error loading avatar image:', e);
        activeAvatarImg.style.display = 'none';
      }
    });

    // Load logos dropdown
    const logoSelect = document.getElementById('logoSelect');
    async function loadLogos() {
      try {
        const res = await fetch(`${API_BASE}/get-logo-library`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        logoSelect.innerHTML = '';
        const list = (data && data.logos) ? data.logos : [];
        if (list.length === 0) {
          logoSelect.innerHTML = '<option value="">No logos found</option>';
          return;
        }

        const activeLogoImg = document.getElementById('activeLogoImg');
        let activeLogo = null;

        list.forEach(logo => {
          const opt = document.createElement('option');
          opt.value = logo.id;
          opt.textContent = logo.name || logo.filename || logo.id;
          if (logo.active) {
            opt.selected = true;
            activeLogo = logo;
          }
          logoSelect.appendChild(opt);
        });

        // Display active logo image
        if (activeLogo && activeLogoImg) {
          activeLogoImg.src = activeLogo.url;
          activeLogoImg.style.display = 'inline-block';
          console.log('Active logo loaded:', activeLogo.name, activeLogo.url);
        } else if (activeLogoImg) {
          activeLogoImg.style.display = 'none';
        }
      } catch (e) {
        console.error('Error loading logos:', e);
        logoSelect.innerHTML = '<option value="">Error loading logos</option>';
        const activeLogoImg = document.getElementById('activeLogoImg');
        if (activeLogoImg) activeLogoImg.style.display = 'none';
      }
    }
    loadLogos();

    // Update logo image when selection changes
    logoSelect.addEventListener('change', async () => {
      const activeLogoImg = document.getElementById('activeLogoImg');
      if (!activeLogoImg) return;

      const selectedId = logoSelect.value;
      if (!selectedId) {
        activeLogoImg.style.display = 'none';
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/get-logo-library`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        const list = (data && data.logos) ? data.logos : [];
        const selectedLogo = list.find(logo => logo.id === selectedId);

        if (selectedLogo && selectedLogo.url) {
          activeLogoImg.src = selectedLogo.url;
          activeLogoImg.style.display = 'inline-block';
          console.log('Logo changed to:', selectedLogo.name, selectedLogo.url);
        } else {
          activeLogoImg.style.display = 'none';
        }
      } catch (e) {
        console.error('Error loading logo image:', e);
        activeLogoImg.style.display = 'none';
      }
    });

    // Load topic keywords/tags from localStorage or API fallback
    (function loadTopicMeta() {
      const tokensEl = document.getElementById('topicTokens');
      function renderTokens(arr){
        tokensEl.innerHTML = '';
        const target = () => (document.querySelector('input[name="memeTarget"]:checked')?.value || 'bottom');
        arr.slice(0, 50).forEach(t => {
          const chip = document.createElement('span');
          chip.textContent = t;
          chip.style.cssText = 'background:#1e3a8a; border-radius:14px; padding:6px 10px; font-size:12px; cursor:pointer;';
          chip.onclick = () => {
            const which = target();
            const input = which === 'top' ? document.getElementById('memeTop') : document.getElementById('memeBottom');
            const sep = input.value && !input.value.endsWith(' ') ? ' ' : '';
            input.value = input.value + sep + t;
          };
          tokensEl.appendChild(chip);
        });
      }

      try {
        let arr = [];
        const saved = localStorage.getItem('editingTopic');
        if (saved) {
          const topic = JSON.parse(saved);
          applyTopicToUI(topic);
          const kw = topic.keywords || [];
          const yt = topic.yt_tags || [];
          arr = [...new Set([...(kw||[]), ...(yt||[])])];
        }
        if (arr.length > 0) { renderTokens(arr); return; }
      } catch {}
      // Fallback: ask API for last selected topic
      fetch(`${API_BASE}/get-selected-topic`).then(r => r.json()).then(d => {
        if (d && d.success && d.topic) {
          const t = d.topic;
          applyTopicToUI(t);
          const kw = t.keywords || [];
          const yt = t.yt_tags || [];
          const arr = [...new Set([...(kw||[]), ...(yt||[])])];
          if (arr.length) renderTokens(arr);
        }
      }).catch(()=>{});
    })();

    // Generate AI background
    document.getElementById('memeGenBg').addEventListener('click', async () => {
      const title = document.getElementById('topicTitle').value.trim();
      const hook = document.getElementById('topicHook').value.trim();
      const desc = document.getElementById('topicDesc').value.trim();
      // Collect tokens
      const chips = Array.from(document.getElementById('topicTokens').children || []);
      const keywords = chips.map(ch => ch.textContent).slice(0, 20);
      const loadingBar = document.getElementById('loadingBar');
      if (loadingBar) loadingBar.style.display = 'block';
      setStatus('Generating background...', 'info');
      try {
        // Prepare user prompt
          const ta = document.getElementById('memePrompt');
          let userPrompt = (ta && ta.value ? ta.value : DEFAULT_PROMPT);
          userPrompt = userPrompt.replace(/\{\{\s*title\s*\}\}/g, title || '');
          userPrompt = userPrompt.replace(/\{\{\s*hook\s*\}\}/g, hook || '');
          userPrompt = userPrompt.replace(/\{\{\s*description\s*\}\}/g, desc || '');

        // Prefer new clean background route; fallback to legacy if not av-ailable
        let res = await fetch(`${API_BASE}/generate-clean-bg`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title, hook, description: desc, keywords, prompt: userPrompt, enforce_no_text: document.getElementById('forceCleanBg').checked })
        }).catch(()=>null);
        if (!res || !res.ok) {
          res = await fetch(`${API_BASE}/generate-meme-bg`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title, hook, description: desc, keywords })
          });
        }
        const data = await res.json();
        if (!data.success) throw new Error(data.error || 'Failed to generate');

        const drawClean = () => {
          const canvas = document.getElementById('memecanvas');
          const ctx = canvas.getContext('2d');
          const w = canvas.width, h = canvas.height;
          // gradient background
          const g = ctx.createLinearGradient(0, 0, 0, h);
          g.addColorStop(0, '#101827');
          g.addColorStop(1, '#0b0f19');
          ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
          // soft vignette stripes
          ctx.globalAlpha = 0.08; ctx.strokeStyle = '#ffffff';
          for (let x = 0; x < w; x += 10) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x - 220, h); ctx.stroke(); }
          ctx.globalAlpha = 1;
        };

        const forceClean = document.getElementById('forceCleanBg').checked;
        const looksLikeOld = !data.source && /thumb_variant/i.test(data.file || data.url || '');
        // Fallback to local gradient only if the backend clearly returned the old text overlay or failed
        if (looksLikeOld) {
          drawClean();
          if (loadingBar) loadingBar.style.display = 'none';
          setStatus('Clean background (local fallback).', 'ok');
          return;
        }

        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const canvas = document.getElementById('memecanvas');
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          if (loadingBar) loadingBar.style.display = 'none';
          setStatus('Background generated.', 'ok');
        };
        img.src = data.url;
      } catch (e) {
        // If backend request failed and user asked for force clean, render local gradient
        if (document.getElementById('forceCleanBg').checked) {
          const canvas = document.getElementById('memecanvas');
          const ctx = canvas.getContext('2d');
          // drawClean inline (av-oid referencing abov-e scope if error path)
          const w = canvas.width, h = canvas.height;
          const g = ctx.createLinearGradient(0, 0, 0, h);
          g.addColorStop(0, '#101827'); g.addColorStop(1, '#0b0f19');
          ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
          ctx.globalAlpha = 0.08; ctx.strokeStyle = '#ffffff';
          for (let x = 0; x < w; x += 10) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x - 220, h); ctx.stroke(); }
          ctx.globalAlpha = 1;
          if (loadingBar) loadingBar.style.display = 'none';
          setStatus('Clean background (local fallback).', 'ok');
        } else {
          if (loadingBar) loadingBar.style.display = 'none';
          setStatus('Error: ' + e.message, 'err');
        }
      }
    });

    mainInput.addEventListener('change', () => {
      const f = mainInput.files && mainInput.files[0];
      approveBtn.disabled = !f;
      if (f) {
        try {
          const url = URL.createObjectURL(f);
          preview.src = url; preview.style.display = 'block'; preview.load();
        } catch {}
      }
    });

    approveBtn.addEventListener('click', async () => {
      const f = mainInput.files && mainInput.files[0];
      if (!f) { alert('Pick a video'); return; }
      approveBtn.disabled = true;
      setStatus('Processing‚Ä¶', 'info');
      try {
        const fd = new FormData();
        fd.append('video', f);
        // 'use_did' indicates Include avatar; 'avatar_static' is inverse of the Animated checkbox
        fd.append('use_did', toggleAvatar.checked ? 'true' : 'false');
        const animated = document.getElementById('avatarAnimated').checked;
        const skipDID = document.getElementById('skipDID').checked;
        fd.append('avatar_static', animated ? 'false' : 'true');
        fd.append('skip_did', skipDID ? 'true' : 'false');
        fd.append('add_intro_outro', toggleIntroOutro.checked ? 'true' : 'false');
        if (toggleAvatar.checked && avatarSelect.value) {
          fd.append('avatar_id', avatarSelect.value);
        }
        // Pass include_logo flag so backend can skip overlay if off
        fd.append('include_logo', toggleLogo.checked ? 'true' : 'false');
        // Explicitly pass the active logo filename to guarantee correct file is used
        try {
          const lib = await fetch(`${API_BASE}/get-logo-library`).then(r => r.json());
          const active = (lib && Array.isArray(lib.logos)) ? lib.logos.find(l => l.active) : null;
          if (active && active.filename) {
            fd.append('logo_filename', active.filename);
          }
        } catch {}
        const resp = await fetch(`${API_BASE}/post-process-video`, { method: 'POST', body: fd });
        if (!resp.ok) {
          const t = await resp.text();
          throw new Error(`HTTP ${resp.status} ${resp.statusText}: ${t.slice(0,200)}`);
        }
        const data = await resp.json();
        if (!data.success) throw new Error(data.error || 'Unknown error');
        setStatus('Done!', 'ok');
        const url = `${API_BASE}/out/${data.files.final_video}`;
        preview.src = url; preview.style.display = 'block'; preview.load();
      } catch (e) {
        console.error(e);
        setStatus(`Error: ${e.message}`, 'err');
        showToast(`Error: ${e.message}`, 'error', 6000);
      } finally { approveBtn.disabled = false; }
    });

    // Auto-save workspace every 30 seconds
    let autoSaveTimer = null;
    let lastSaved = null;

    function saveWorkspace() {
      const workspace = {
        title: document.getElementById('topicTitle')?.value || '',
        hook: document.getElementById('topicHook')?.value || '',
        desc: document.getElementById('topicDesc')?.value || '',
        memeTop: document.getElementById('memeTop')?.value || '',
        memeBottom: document.getElementById('memeBottom')?.value || '',
        timestamp: Date.now()
      };

      localStorage.setItem('mss_autosave', JSON.stringify(workspace));
      lastSaved = new Date();

      // Save to recent topics
      const recent = JSON.parse(localStorage.getItem('mss_recent_topics') || '[]');
      if (workspace.title || workspace.hook) {
        const exists = recent.findIndex(r => r.title === workspace.title && r.hook === workspace.hook);
        if (exists >= 0) recent.splice(exists, 1);
        recent.unshift(workspace);
        localStorage.setItem('mss_recent_topics', JSON.stringify(recent.slice(0, 10)));
      }

      console.log('Workspace auto-saved:', new Date().toLocaleTimeString());
    }

    function loadWorkspace() {
      const saved = localStorage.getItem('mss_autosave');
      if (!saved) return false;

      try {
        const workspace = JSON.parse(saved);
        const age = Date.now() - workspace.timestamp;

        // Only restore if less than 24 hours old
        if (age < 24 * 60 * 60 * 1000) {
          if (workspace.title && !document.getElementById('topicTitle').value) {
            document.getElementById('topicTitle').value = workspace.title;
          }
          if (workspace.hook && !document.getElementById('topicHook').value) {
            document.getElementById('topicHook').value = workspace.hook;
          }
          if (workspace.desc && !document.getElementById('topicDesc').value) {
            document.getElementById('topicDesc').value = workspace.desc;
          }
          if (workspace.memeTop && !document.getElementById('memeTop').value) {
            document.getElementById('memeTop').value = workspace.memeTop;
          }
          if (workspace.memeBottom && !document.getElementById('memeBottom').value) {
            document.getElementById('memeBottom').value = workspace.memeBottom;
          }
          return true;
        }
      } catch (e) {
        console.error('Failed to load workspace:', e);
      }
      return false;
    }

    // Auto-save on input changes
    ['topicTitle', 'topicHook', 'topicDesc', 'memeTop', 'memeBottom'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener('input', () => {
          clearTimeout(autoSaveTimer);
          autoSaveTimer = setTimeout(saveWorkspace, 30000); // 30 seconds
        });
        // Also save on blur (when user leaves field)
        el.addEventListener('blur', saveWorkspace);
      }
    });

    // Load workspace on page load
    setTimeout(() => {
      if (loadWorkspace()) {
        showToast('üìù Previous draft restored', 'success', 3000);
      }
    }, 500);

    // Live thumbnail preview
    let previewTimer = null;
    function updateLivePreview() {
      clearTimeout(previewTimer);
      previewTimer = setTimeout(() => {
        const top = document.getElementById('memeTop').value;
        const bottom = document.getElementById('memeBottom').value;

        if (top || bottom) {
          const canvas = document.getElementById('memecanvas');
          const ctx = canvas.getContext('2d');
          const w = canvas.width, h = canvas.height;

          // Only update if canvas is mostly empty (no background loaded)
          const imageData = ctx.getImageData(0, 0, w, h);
          const isEmpty = imageData.data.every((val, i) => i % 4 === 3 || val === 0);

          if (isEmpty || !document.getElementById('memeBg').files?.length) {
            // Gradient background
            const g = ctx.createLinearGradient(0, 0, 0, h);
            g.addColorStop(0, '#101827');
            g.addColorStop(1, '#0b0f19');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, w, h);

            // Draw text preview
            const selectedFont = document.getElementById('memeFont')?.value || 'Impact';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 8;
            ctx.font = `bold 72px ${selectedFont}, sans-serif`;

            if (top) {
              ctx.strokeText(top.toUpperCase(), w/2, 120);
              ctx.fillText(top.toUpperCase(), w/2, 120);
            }
            if (bottom) {
              ctx.strokeText(bottom.toUpperCase(), w/2, h - 60);
              ctx.fillText(bottom.toUpperCase(), w/2, h - 60);
            }
          }
        }
      }, 500);
    }

    document.getElementById('memeTop')?.addEventListener('input', updateLivePreview);
    document.getElementById('memeBottom')?.addEventListener('input', updateLivePreview);
    document.getElementById('memeFont')?.addEventListener('change', updateLivePreview);

    // Drag and Drop for Canvas
    const canvas = document.getElementById('memecanvas');

    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
      canvas.style.borderColor = 'var(--accent-blue)';
      canvas.style.opacity = '0.7';
    });

    canvas.addEventListener('dragleave', (e) => {
      e.preventDefault();
      canvas.style.borderColor = '';
      canvas.style.opacity = '1';
    });

    canvas.addEventListener('drop', (e) => {
      e.preventDefault();
      canvas.style.borderColor = '';
      canvas.style.opacity = '1';

      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            showToast('üñºÔ∏è Background loaded', 'success', 2000);
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      } else {
        showToast('Please drop an image file', 'error', 2000);
      }
    });

    // Recent Topics Toggle
    const recentBtn = document.getElementById('showRecentBtn');
    const recentPanel = document.getElementById('recentTopics');
    const recentList = document.getElementById('recentList');

    function renderRecentTopics() {
      const recent = JSON.parse(localStorage.getItem('mss_recent_topics') || '[]');
      if (recent.length === 0) {
        recentList.innerHTML = '<div style="color:var(--text-muted); font-size:12px;">No recent topics yet</div>';
        return;
      }

      recentList.innerHTML = recent.map((item, idx) => {
        const time = new Date(item.timestamp).toLocaleString();
        return `
          <div class="recent-item" data-index="${idx}" style="padding:8px; margin:4px 0; background:rgba(255,255,255,0.05); border-radius:4px; cursor:pointer; transition:background 0.15s;">
            <div style="font-weight:600; font-size:13px;">${item.title || 'Untitled'}</div>
            <div style="font-size:11px; color:var(--text-muted);">${item.hook || ''}</div>
            <div style="font-size:10px; color:var(--text-version); margin-top:4px;">${time}</div>
          </div>
        `;
      }).join('');

      // Add click handlers
      recentList.querySelectorAll('.recent-item').forEach(el => {
        el.addEventListener('click', () => {
          const idx = parseInt(el.dataset.index);
          const item = recent[idx];
          document.getElementById('topicTitle').value = item.title || '';
          document.getElementById('topicHook').value = item.hook || '';
          document.getElementById('topicDesc').value = item.desc || '';
          document.getElementById('memeTop').value = item.memeTop || '';
          document.getElementById('memeBottom').value = item.memeBottom || '';
          recentPanel.style.display = 'none';
          showToast('üìÇ Topic loaded', 'success', 2000);
          updateLivePreview();
        });
        el.addEventListener('mouseenter', () => {
          el.style.background = 'rgba(59,130,246,0.2)';
        });
        el.addEventListener('mouseleave', () => {
          el.style.background = 'rgba(255,255,255,0.05)';
        });
      });
    }

    recentBtn?.addEventListener('click', () => {
      const isVisible = recentPanel.style.display === 'block';
      recentPanel.style.display = isVisible ? 'none' : 'block';
      if (!isVisible) renderRecentTopics();
    });

    // Batch Background Generation
    document.getElementById('batchGenBg')?.addEventListener('click', async () => {
      const title = document.getElementById('topicTitle').value.trim();
      const hook = document.getElementById('topicHook').value.trim();
      const desc = document.getElementById('topicDesc').value.trim();
      const chips = Array.from(document.getElementById('topicTokens')?.children || []);
      const keywords = chips.map(ch => ch.textContent).slice(0, 20);
      const loadingBar = document.getElementById('loadingBar');

      if (!title && !hook) {
        showToast('Please enter a title or hook first', 'error', 3000);
        return;
      }

      if (loadingBar) loadingBar.style.display = 'block';
      showToast('üé® Generating 5 variants... this may take a minute', 'info', 3000);

      const variants = [];
      for (let i = 0; i < 5; i++) {
        try {
          const ta = document.getElementById('memePrompt');
          let userPrompt = (ta && ta.value ? ta.value : DEFAULT_PROMPT);
          userPrompt = userPrompt.replace(/\{\{\s*title\s*\}\}/g, title || '');
          userPrompt = userPrompt.replace(/\{\{\s*hook\s*\}\}/g, hook || '');
          userPrompt = userPrompt.replace(/\{\{\s*description\s*\}\}/g, desc || '');

          // Add variety to each variant
          const styleVariants = [
            'vibrant and energetic',
            'professional and clean',
            'dramatic and bold',
            'modern and minimalist',
            'warm and inviting'
          ];
          userPrompt += `\n\nStyle emphasis: ${styleVariants[i]}`;

          const res = await fetch(`${API_BASE}/generate-clean-bg`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              title, hook, description: desc, keywords,
              prompt: userPrompt,
              enforce_no_text: document.getElementById('forceCleanBg').checked
            })
          });

          if (res.ok) {
            const data = await res.json();
            if (data.success) {
              variants.push(data.url);
              showToast(`‚úì Variant ${i + 1}/5 generated`, 'success', 2000);
            }
          }
        } catch (e) {
          console.error('Variant generation error:', e);
        }
      }

      if (loadingBar) loadingBar.style.display = 'none';

      if (variants.length > 0) {
        // Display all variants below the canvas
        let variantHTML = '<div style="margin-top:16px;"><h3 style="margin-bottom:8px;">Generated Variants (click to use):</h3><div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px;">';
        variants.forEach((url, idx) => {
          variantHTML += `<img src="${url}" onclick="
            const canvas = document.getElementById('memecanvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              showToast('Variant ${idx + 1} applied', 'success', 2000);
            };
            img.src = '${url}';
          " style="width:100%; border-radius:8px; cursor:pointer; border:2px solid transparent; transition:border-color 0.2s;" onmouseenter="this.style.borderColor='var(--accent-blue)'" onmouseleave="this.style.borderColor='transparent'">`;
        });
        variantHTML += '</div></div>';

        const canvasRow = document.getElementById('memecanvas').parentElement;
        const existing = canvasRow.querySelector('.variants-grid');
        if (existing) existing.remove();

        const div = document.createElement('div');
        div.className = 'variants-grid';
        div.innerHTML = variantHTML;
        canvasRow.appendChild(div);

        showToast(`üéâ ${variants.length} variants ready!`, 'success', 4000);
      } else {
        showToast('‚ùå Failed to generate variants', 'error', 4000);
      }
    });

    // Template System
    const templatePanel = document.getElementById('templatePanel');
    const templateList = document.getElementById('templateList');

    function saveTemplate() {
      const name = prompt('Enter a name for this template:');
      if (!name) return;

      const template = {
        name,
        title: document.getElementById('topicTitle').value,
        hook: document.getElementById('topicHook').value,
        desc: document.getElementById('topicDesc').value,
        memeTop: document.getElementById('memeTop').value,
        memeBottom: document.getElementById('memeBottom').value,
        forceClean: document.getElementById('forceCleanBg').checked,
        timestamp: Date.now()
      };

      const templates = JSON.parse(localStorage.getItem('mss_templates') || '[]');
      templates.push(template);
      localStorage.setItem('mss_templates', JSON.stringify(templates));
      showToast(`üíæ Template "${name}" saved`, 'success', 3000);
    }

    function renderTemplates() {
      const templates = JSON.parse(localStorage.getItem('mss_templates') || '[]');
      if (templates.length === 0) {
        templateList.innerHTML = '<div style="color:var(--text-muted); font-size:12px;">No templates saved yet</div>';
        return;
      }

      templateList.innerHTML = templates.map((tpl, idx) => {
        const time = new Date(tpl.timestamp).toLocaleDateString();
        return `
          <div class="template-item" data-index="${idx}" style="padding:10px; margin:4px 0; background:rgba(124,58,237,0.15); border-radius:4px; cursor:pointer; transition:background 0.15s; position:relative;">
            <div style="display:flex; justify-content:space-between; align-items:start;">
              <div style="flex:1;">
                <div style="font-weight:600; font-size:14px; color:#c084fc;">${tpl.name}</div>
                <div style="font-size:12px; color:var(--text-muted); margin-top:2px;">${tpl.title || 'No title'}</div>
                <div style="font-size:10px; color:var(--text-version); margin-top:4px;">Saved: ${time}</div>
              </div>
              <button class="delete-template" data-index="${idx}" style="background:#ef4444; border:none; color:white; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:11px;">‚úï</button>
            </div>
          </div>
        `;
      }).join('');

      // Add click handlers
      templateList.querySelectorAll('.template-item').forEach(el => {
        el.addEventListener('click', (e) => {
          if (e.target.classList.contains('delete-template')) return;
          const idx = parseInt(el.dataset.index);
          const tpl = templates[idx];
          document.getElementById('topicTitle').value = tpl.title || '';
          document.getElementById('topicHook').value = tpl.hook || '';
          document.getElementById('topicDesc').value = tpl.desc || '';
          document.getElementById('memeTop').value = tpl.memeTop || '';
          document.getElementById('memeBottom').value = tpl.memeBottom || '';
          document.getElementById('forceCleanBg').checked = tpl.forceClean !== false;
          templatePanel.style.display = 'none';
          showToast(`üìÅ Template "${tpl.name}" loaded`, 'success', 2000);
          updateLivePreview();
        });
        el.addEventListener('mouseenter', () => {
          el.style.background = 'rgba(124,58,237,0.3)';
        });
        el.addEventListener('mouseleave', () => {
          el.style.background = 'rgba(124,58,237,0.15)';
        });
      });

      // Delete template handlers
      templateList.querySelectorAll('.delete-template').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = parseInt(btn.dataset.index);
          if (confirm(`Delete template "${templates[idx].name}"?`)) {
            templates.splice(idx, 1);
            localStorage.setItem('mss_templates', JSON.stringify(templates));
            renderTemplates();
            showToast('Template deleted', 'success', 2000);
          }
        });
      });
    }

    document.getElementById('saveTemplateBtn')?.addEventListener('click', saveTemplate);
    document.getElementById('loadTemplateBtn')?.addEventListener('click', () => {
      const isVisible = templatePanel.style.display === 'block';
      templatePanel.style.display = isVisible ? 'none' : 'block';
      if (!isVisible) renderTemplates();
    });

    // Export/Import System
    document.getElementById('exportBtn')?.addEventListener('click', () => {
      const exportData = {
        version: '3.2.0',
        exported: new Date().toISOString(),
        templates: JSON.parse(localStorage.getItem('mss_templates') || '[]'),
        recentTopics: JSON.parse(localStorage.getItem('mss_recent_topics') || '[]'),
        autosave: JSON.parse(localStorage.getItem('mss_autosave') || 'null'),
        stats: JSON.parse(localStorage.getItem('mss_stats') || '{}')
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `mss-backup-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      showToast('üì¶ Data exported successfully', 'success', 3000);
    });

    document.getElementById('importBtn')?.addEventListener('click', () => {
      document.getElementById('importFileInput').click();
    });

    document.getElementById('importFileInput')?.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target.result);

          if (confirm('Import data? This will merge with existing templates and topics.')) {
            if (data.templates) {
              const existing = JSON.parse(localStorage.getItem('mss_templates') || '[]');
              const merged = [...existing, ...data.templates];
              localStorage.setItem('mss_templates', JSON.stringify(merged));
            }
            if (data.recentTopics) {
              const existing = JSON.parse(localStorage.getItem('mss_recent_topics') || '[]');
              const merged = [...data.recentTopics, ...existing].slice(0, 20);
              localStorage.setItem('mss_recent_topics', JSON.stringify(merged));
            }
            showToast('‚úÖ Data imported successfully', 'success', 3000);
          }
        } catch (err) {
          showToast('‚ùå Invalid import file', 'error', 3000);
        }
      };
      reader.readAsText(file);
      e.target.value = ''; // Reset file input
    });

    // Analytics Tracking
    function trackEvent(eventType, data = {}) {
      const stats = JSON.parse(localStorage.getItem('mss_stats') || '{}');
      if (!stats.events) stats.events = [];

      stats.events.push({
        type: eventType,
        timestamp: Date.now(),
        ...data
      });

      // Keep only last 100 events
      if (stats.events.length > 100) {
        stats.events = stats.events.slice(-100);
      }

      // Update counters
      if (!stats.counters) stats.counters = {};
      stats.counters[eventType] = (stats.counters[eventType] || 0) + 1;
      stats.counters.total = (stats.counters.total || 0) + 1;
      stats.lastActivity = Date.now();

      localStorage.setItem('mss_stats', JSON.stringify(stats));
    }

    // Track thumbnail generation
    const originalMemeGenerate = document.getElementById('memeGenerate');
    originalMemeGenerate?.addEventListener('click', () => {
      trackEvent('thumbnail_generated', {
        hasBackground: !!document.getElementById('memeBg').files?.length
      });
    });

    // Track background generation
    const originalGenBg = document.getElementById('memeGenBg');
    if (originalGenBg) {
      originalGenBg.addEventListener('click', () => {
        trackEvent('background_generated', { type: 'single' });
      });
    }

    // Track batch generation
    const batchBtn = document.getElementById('batchGenBg');
    if (batchBtn) {
      batchBtn.addEventListener('click', () => {
        trackEvent('background_generated', { type: 'batch', count: 5 });
      });
    }

    // Show basic stats on console
    setTimeout(() => {
      const stats = JSON.parse(localStorage.getItem('mss_stats') || '{}');
      if (stats.counters) {
        console.log('üìä MSS Analytics:', stats.counters);
        console.log(`Total actions: ${stats.counters.total || 0}`);
      }
    }, 2000);

    // AI Script Generator
    document.getElementById('generateScript')?.addEventListener('click', async () => {
      const title = document.getElementById('topicTitle')?.value || '';
      const hook = document.getElementById('topicHook')?.value || '';
      const desc = document.getElementById('topicDesc')?.value || '';
      const length = document.getElementById('scriptLength')?.value || 'medium';
      const style = document.getElementById('scriptStyle')?.value || 'informative';

      if (!title && !hook) {
        showToast('Please enter a title or hook first', 'error', 3000);
        return;
      }

      const scriptStatus = document.getElementById('scriptStatus');
      const generateBtn = document.getElementById('generateScript');
      const loadingBar = document.getElementById('loadingBar');

      scriptStatus.style.display = 'block';
      scriptStatus.className = 'status info';
      scriptStatus.textContent = 'Generating script with AI...';
      generateBtn.disabled = true;
      if (loadingBar) loadingBar.style.display = 'block';

      try {
        const lengthMap = {
          'short': '30-60 seconds, around 100-150 words',
          'medium': '2-3 minutes, around 300-450 words',
          'long': '5-8 minutes, around 750-1200 words'
        };

        const styleMap = {
          'informative': 'educational and informative, teaching the audience something new',
          'entertaining': 'entertaining and engaging, keeping viewers hooked with energy and personality',
          'dramatic': 'dramatic storytelling style, building tension and narrative arc',
          'casual': 'casual and conversational, like talking to a friend',
          'professional': 'professional news-style, authoritative and credible'
        };

        const prompt = `You are a professional YouTube script writer. Create a compelling video script for the following video:

Title: ${title}
Hook/Angle: ${hook}
Description: ${desc}

Script Requirements:
- Length: ${lengthMap[length]}
- Style: ${styleMap[style]}
- Include a strong opening hook (first 5 seconds)
- Clear structure with introduction, main content, and conclusion
- Include natural pauses and transitions
- End with a clear call-to-action
- Write for spoken word (conversational, not academic)
- Use "you" to directly address the viewer

Format the script with clear sections like:
[HOOK - 0:00-0:05]
[INTRO - 0:05-0:20]
[MAIN CONTENT]
[CONCLUSION]
[CTA]

Make it engaging and optimized for viewer retention.`;

        const res = await fetch(`${API_BASE}/generate-script`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: prompt,
            title: title,
            hook: hook,
            description: desc,
            length: length,
            style: style
          })
        });

        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }

        const data = await res.json();

        if (!data.success || !data.script) {
          throw new Error(data.error || 'Failed to generate script');
        }

        // Display the script
        const scriptOutput = document.getElementById('scriptOutput');
        const scriptOutputRow = document.getElementById('scriptOutputRow');
        const copyBtn = document.getElementById('copyScript');

        scriptOutput.value = data.script;
        scriptOutputRow.style.display = 'block';
        copyBtn.style.display = 'inline-block';

        // Update stats
        const words = data.script.split(/\s+/).length;
        const duration = Math.round(words / 2.5); // ~150 words per minute = 2.5 words per second
        document.getElementById('scriptWordCount').textContent = `Words: ${words}`;
        document.getElementById('scriptDuration').textContent = `Est. Duration: ${Math.floor(duration / 60)}:${(duration % 60).toString().padStart(2, '0')}`;

        scriptStatus.className = 'status ok';
        scriptStatus.textContent = '‚úÖ Script generated successfully!';
        showToast('üé¨ Script generated!', 'success', 3000);

        // Track event
        trackEvent('script_generated', { length, style, words });

      } catch (e) {
        console.error('Script generation error:', e);
        scriptStatus.className = 'status err';
        scriptStatus.textContent = `Error: ${e.message}`;
        showToast(`‚ùå Script generation failed: ${e.message}`, 'error', 5000);
      } finally {
        generateBtn.disabled = false;
        if (loadingBar) loadingBar.style.display = 'none';
      }
    });

    // Copy script button
    document.getElementById('copyScript')?.addEventListener('click', () => {
      const scriptOutput = document.getElementById('scriptOutput');
      scriptOutput.select();
      document.execCommand('copy');
      showToast('üìã Script copied to clipboard', 'success', 2000);
    });

    // Update word count on edit
    document.getElementById('scriptOutput')?.addEventListener('input', (e) => {
      const words = e.target.value.split(/\s+/).filter(w => w.length > 0).length;
      const duration = Math.round(words / 2.5);
      document.getElementById('scriptWordCount').textContent = `Words: ${words}`;
      document.getElementById('scriptDuration').textContent = `Est. Duration: ${Math.floor(duration / 60)}:${(duration % 60).toString().padStart(2, '0')}`;
    });

    // Welcome message with keyboard shortcuts
    setTimeout(() => {
      showToast('üí° Shortcuts: Ctrl+Z (Undo), Ctrl+Y (Redo), Ctrl+S (Generate), Ctrl+G (Background)', 'info', 6000);
    }, 1000);
  </script>
</body>
</html>













